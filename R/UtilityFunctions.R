# All the utility functions ----

#' ConcatenateClusteringDetails
#'
#' Given a TrackSOM object and a DataFrame containing cells from all time
#' points, extract all the meta clusters, clusters, and tracking id and combine
#' them with the cell information.
#'
#' @param tracksom.result TrackSOM object as generated by \code{\link{TrackSOM}}
#' @param dat Dataframe containing all cells from all time points
#' @param divide.by Character showing column name of the dataframe that indicate
#'   the time point of each cell
#'
#' @return Dataframe containing the meta cluster, cluster, and tracking ids for
#'   all the cells
#'
#' @import data.table
#'
#' @examples
#'
#' library(data.table)
#' data_files <- sapply(c(0:4), function(i) {
#'   system.file("extdata", paste0("synthetic_d", i, ".fcs"), package="TrackSOM")
#' })
#' use_cols <- c("x", "y", "z")
#' tracksom_result <- TrackSOM(inputFiles = data_files,
#'                             colsToUse = use_cols,
#'                             nClus = 10,
#'                             dataFileType = ".fcs"
#' )
#'
#' data <- lapply(c(0:4), function(i) {
#'   fread(system.file("extdata", paste0("synthetic_d", i, ".csv"), package="TrackSOM"))
#' })
#' data <- rbindlist(data)
#' tracksom_res <- ConcatenateClusteringDetails(
#'   data,
#'   tracksom_result,
#'   timepoint.col = 'timepoint',
#'   timepoints = c("Mock", "SYN-1", "SYN-2", "SYN-3", "SYN-4")
#' )
#'
#' @export
#'
ConcatenateClusteringDetails <- function(tracksom.result,
                                         dat,
                                         timepoint.col,
                                         timepoints) {


  time.points <- names(tracksom.result$metaclustering$mcPerCell)

  cell.dat <- data.table(dat)

  # append the cluster/code to cell.dat
  fsom.code.colname <- 'TrackSOM_cluster'
  fsom.codes <- data.table(tracksom.result$FlowSOM$map$mapping[, 1])
  names(fsom.codes) <- fsom.code.colname
  cell.dat <- cbind(cell.dat, fsom.codes)

  # divide cell.dat based on the time point
  cell.dat.list <- lapply(timepoints, function(i) {
    return(cell.dat[cell.dat[[timepoint.col]] == i,])
  })

  metacluster.per.tp <- lapply(time.points, function(time.point) {
    return(tracksom.result$metaclustering$mcPerCell[[time.point]])
  })

  # get the lineage id for all cells in all time point
  lineage.ids.per.tp <- lapply(seq_along(cell.dat.list), function(i) {
    # isolate just the code for all cells in a time point
    c.dat <- cell.dat.list[[i]]
    fsom.code <- c.dat[[fsom.code.colname]]

    # get the lineage id for each code. TrackSOM output the lineage id of the
    # code instead of metacluster, thus complicated.
    lineage.fsom.code.mapping <-
      tracksom.result$tracking$lineage[[paste("timestep", i, sep = "_")]]

    # code mapping is stored in numerical order i.e. vector index 1 is for code
    # 1. thus to get the lineage id for code 1, just access the value inside
    # vector index 1
    fsom.code.mapped <- sapply(fsom.code, function(code){
      return(lineage.fsom.code.mapping[code])
    })

    return(fsom.code.mapped)
  })

  # append the meta cluster and lineage id onto the cells dataframe
  complete.cell.dat.list <- lapply(seq_along(cell.dat.list), function(i) {
    c.dat <- data.table(cell.dat.list[[i]])

    metaclusters <- data.table(metacluster.per.tp[[i]])
    names(metaclusters) <- "TrackSOM_metacluster"

    lineage.ids <- data.table(lineage.ids.per.tp[[i]])
    names(lineage.ids) <- "TrackSOM_metacluster_lineage_tracking"

    c.dat <- cbind(c.dat, metaclusters, lineage.ids)

    return(c.dat)

  })

  # combine everything into 1 giant data frame
  complete.cell.dat <- rbindlist(complete.cell.dat.list)

  complete.cell.dat <- data.table(complete.cell.dat)

  return(complete.cell.dat)
}

#' ExportClusteringDetailsOnly
#'
#' Given a TrackSOM object export the clustering result as data.table.
#'
#' @param tracksom.result TrackSOM object as generated by \code{\link{TrackSOM}}
#'
#' @return Data.table containing the meta cluster, cluster, and tracking ids for
#'   all the cells
#'
#' @import data.table
#'
#' @examples
#' \dontrun{
#' data_files <- sapply(c(0:4), function(i) {
#' system.file("extdata", paste0("synthetic_d", i, ".fcs"), package="TrackSOM")
#' })
#' use_cols <- c("x", "y", "z")
#' tracksom_result <- TrackSOM(inputFiles = data_files,
#'                             colsToUse = use_cols,
#'                             nClus = 10,
#'                             dataFileType = ".fcs"
#' )
#' tracksom_res <- ExportClusteringDetailsOnly(tracksom_result)
#' }
#'
#' @export
#'
ExportClusteringDetailsOnly <- function(tracksom.result) {

  result <- data.table(TrackSOM_cluster=tracksom.result$FlowSOM$map$mapping[, 1])
  result$row_index <- c(1:nrow(result))

  result$TrackSOM_metacluster <-
    unlist(tracksom.result$metaclustering$mcPerCell, use.names = FALSE)

  # have to infer the timepoint of each row in result
  num_rows_per_timepoint <- tracksom.result$FlowSOM$metaData

  timepoints <- lapply(c(1:length(num_rows_per_timepoint)), function(timepoint) {
    # timepoint = 1
    row_range <- num_rows_per_timepoint[[timepoint]]
    num_row <- row_range[2] - row_range[1] + 1
    return(rep(paste0("timestep_", timepoint), num_row))
  })
  timepoints <- unlist(timepoints, use.names = FALSE)
  result$timepoint <- timepoints


  # extract the lineage id stored as vector, and convert to data.table
  timepoints <- names(tracksom.result$tracking$lineage)
  metacluster_lineage_id <- lapply(timepoints, function(tp) {
    # tp = timepoints[1]
    meta_clusters <- tracksom.result[["tracking"]][["lineage"]][[tp]]
    res <- data.table(
      TrackSOM_metacluster_lineage_tracking=meta_clusters,
      timepoint=rep(tp, length(meta_clusters)),
      TrackSOM_cluster=c(1:length(meta_clusters))
    )
    return(res)
  })
  metacluster_lineage_id <- rbindlist(metacluster_lineage_id)
  metacluster_lineage_id <- na.omit(metacluster_lineage_id)

  # do database join
  res_merged <- merge.data.table(result, metacluster_lineage_id)
  res_merged <- res_merged[order(row_index)]

  res_merged$row_index = NULL

  return(res_merged)
}
